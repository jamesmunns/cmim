//! # Cortex-M Interrupt Move
//!
//! It's the next best thing to moving to interrupt context.
//!
//! ## The goal
//!
//! The goal here is to replace usage of a mutex which may require an entire critical section, and instead model "Moving" of data to an interrupt context.
//!
//! This means that we don't need a critical section to access it, we just need to be in the interrupt we moved the data to.

#![no_std]

use bare_metal::Nr;
use core::cell::UnsafeCell;
use core::mem::MaybeUninit;
use core::result::Result;
use core::sync::atomic::AtomicUsize;
use core::sync::atomic::Ordering;
use cortex_m::interrupt::free;
use cortex_m::peripheral::{scb::VectActive, SCB};

pub struct Move<T, I> {
    /// `data` contains the user data, which may or may not be initialized
    data: UnsafeCell<MaybeUninit<T>>,

    // `state` is a runtime tracking of our current state.
    state: AtomicUsize,

    // `inter` is the interrupt type. This type is unique to every chip
    // as it is generated by svd2rust, but all types implement the `Nr`
    // trait
    inter: I,
}

unsafe impl<T, I> Sync for Move<T, I>
where
    T: Send + Sized,
    I: Nr,
{
}

/// Move is a structure that is intended to be stored as a static variable,
/// and represents a metaphorical "move" to an interrupt context. Data is moved
/// to the interrupt context by calling `try_move` from thread (non-interrupt)
/// context, and the data can be retrived within a selected interrupt using the
/// `try_lock` method.
impl<T, I> Move<T, I> {

    /// The data is uninitialized
    const UNINIT: usize = 0;

    /// The data is initialized and not currently locked
    const INIT_AND_IDLE: usize = 1;

    /// The data is initialized, but currently locked by an interrupt
    const LOCKED: usize = 2;

    /// Create a new `Move` structure without initializing the data contained by it.
    /// This is best used when the data cannot be initialized until runtime, such as
    /// a HAL peripheral, or the producer or consumer of a queue.
    ///
    /// Before using this in interrupt context, you must initialize it with the
    /// `try_move` function, or it will return errors upon access.
    ///
    /// You must provide the interrupt that is allowed to later access this data
    /// as the `inter` argument
    pub const fn new_uninitialized(inter: I) -> Self {
        Move {
            data: UnsafeCell::new(MaybeUninit::uninit()),
            inter,
            state: AtomicUsize::new(Self::UNINIT),
        }
    }

    /// Create a new `Move` structure, and initialize the data contained within it.
    /// This is best used when the data contained within is `const`, and doesn't require
    /// runtime initialization.
    ///
    /// This does not require further interaction before use in interrupt context.
    ///
    /// You must provide the interrupt that is allowed to later access this data
    /// as the `inter` argument
    pub const fn new(data: T, inter: I) -> Self {
        Move {
            data: UnsafeCell::new(MaybeUninit::new(data)),
            inter,
            state: AtomicUsize::new(Self::INIT_AND_IDLE),
        }
    }
}

impl<T, I> Move<T, I>
where
    T: Send + Sized,
    I: Nr,
{
    /// Attempt to initialize the data of the `Move` structure.
    /// This *MUST* be called from non-interrupt context, and a critical
    /// section will be in place while setting the data.
    ///
    /// Returns:
    ///
    /// * Ok(Some(T)): If we are in thread mode and the data was previously initialized
    /// * Ok(None): If we are in thread mode and the data was not previously initialized
    /// * Err(T): If we are not in thread mode (e.g. an interrupt is active), return the
    ///     data that was going to be moved
    pub fn try_move(&self, data: T) -> Result<Option<T>, T> {
        free(|_cs| {
            // Check if we are in non-interrupt context
            match SCB::vect_active() {
                // TODO: Would it be reasonable to initialize this from a DIFFERENT
                // interrupt context? Basically anything but the destination interrupt?
                VectActive::ThreadMode => {}
                _ => {
                    return Err(data);
                }
            }

            // Since we are in a critical section, it is not necessary to perform
            // an atomic compare and swap, as we cannot be pre-empted
            match self.state.load(Ordering::SeqCst) {
                Self::UNINIT => {
                    unsafe {
                        // Reference to an uninitialized MaybeUninit
                        let mu_ref = &mut *self.data.get();

                        // Get a pointer to the data, and use ptr::write to avoid
                        // viewing or creating a reference to uninitialized data
                        let dat_ptr = mu_ref.as_mut_ptr();
                        dat_ptr.write(data);
                    }
                    self.state.store(Self::INIT_AND_IDLE, Ordering::SeqCst);
                    Ok(None)
                }
                Self::INIT_AND_IDLE => {
                    let old = unsafe {
                        // Reference to an initialized MaybeUninit
                        let mu_ref = &mut *self.data.get();

                        // Get a pointer to the data, and use ptr::replace,
                        // a mem::swap is probably okay since this is initialized,
                        // but use ptr methods anyway
                        let dat_ptr = mu_ref.as_mut_ptr();
                        dat_ptr.replace(data)
                    };
                    Ok(Some(old))
                }
                Self::LOCKED | _ => Err(data),
            }
        })
    }

    /// Attempt to recover the data from the `Move` structure.
    /// This *MUST* be called from non-interrupt context, and a critical
    /// section will be in place while receiving the data.
    ///
    /// Returns:
    ///
    /// * Ok(Some(T)): If we are in thread mode and the data was previously initialized
    /// * Ok(None): If we are in thread mode and the data was not previously initialized
    /// * Err(()): If we are not in thread mode (e.g. an interrupt is active)
    pub fn try_free(&self) -> Result<Option<T>, ()> {
        free(|_cs| {
            // Check if we are in non-interrupt context
            match SCB::vect_active() {
                // TODO: Would it be reasonable to free this from a DIFFERENT
                // interrupt context? Basically anything but the destination interrupt?
                VectActive::ThreadMode => {}
                _ => {
                    return Err(());
                }
            }

            // Since we are in a critical section, it is not necessary to perform
            // an atomic compare and swap, as we cannot be pre-empted
            match self.state.load(Ordering::SeqCst) {
                Self::UNINIT => Ok(None),
                Self::INIT_AND_IDLE => {
                    let old = unsafe {
                        // Get a pointer to the initialized data
                        let mu_ptr = self.data.get();

                        // Replace it with an uninitialized field. I winder if this is
                        // just a no-op, or if we should explicitly zero the memory here
                        mu_ptr.replace(MaybeUninit::uninit()).assume_init()
                    };

                    self.state.store(Self::UNINIT, Ordering::SeqCst);

                    Ok(Some(old))
                }
                Self::LOCKED | _ => Err(()),
            }
        })
    }

    /// So, this isn't a classical mutex. It will *only* provide access if:
    ///
    /// * The selected interrupt is currently active
    /// * The mutex has not already been locked
    ///
    /// If these conditions are met, then you can access the variable from within
    /// a closure
    pub fn try_lock<R>(&self, f: impl FnOnce(&mut T) -> R) -> Result<R, ()> {
        match SCB::vect_active() {
            VectActive::Interrupt { irqn } if irqn == self.inter.nr() => {
                // Okay to go ahead
            }
            _ => return Err(()),
        };

        // We know that the current interrupt is active, which means
        // that thread mode cannot resume until we exit this function.
        // We don't need to worry about compare and swap, because we
        // are now the only ones who can access this data
        match self.state.load(Ordering::SeqCst) {
            // The data is uninitialized. Don't provide access
            Self::UNINIT => Err(()),

            // The data is initialized, allow access within a closure
            // This prevents re-entrancy of re-calling lock within the
            // closure
            Self::INIT_AND_IDLE => {
                self.state.store(Self::LOCKED, Ordering::SeqCst);

                let dat_ref = unsafe {
                    // Create a mutable reference to an initialized MaybeUninit
                    let mu_ref = &mut *self.data.get();

                    // Create a mutable reference to the initialized data behind
                    // the MaybeUninit. This is fine, because the scope of this
                    // reference can only live to the end of this function, and
                    // cannot be captured by the closure used below.
                    //
                    // Additionally we have a re-entrancy check above, to prevent
                    // creating a duplicate &mut to the inner data
                    let dat_ptr = mu_ref.as_mut_ptr();
                    &mut *dat_ptr
                };

                // Call the user's closure, providing access to the data
                let ret = f(dat_ref);

                self.state.store(Self::INIT_AND_IDLE, Ordering::SeqCst);

                Ok(ret)
            }

            // The data is locked, or the status register is garbage.
            // Don't provide access
            Self::LOCKED | _ => Err(()),
        }
    }
}
